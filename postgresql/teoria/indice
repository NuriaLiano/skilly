
funciones ventana
self join


# objetos básicos

Cluster: Un área de almacenamiento de PostgreSQL en una instancia, compuesta de una o varias bases de datos. Pueden existir varios clusters dentro de una instancia, cada uno con su propio puerto TCP. En terminología MySQL esto se conoce como instancia.
Base de Datos: Una colección de datos organizada en tabla relacionales. No hay diferencia con SQL o MySQL.
Esquema: Coleccione de tablas dentro de una base de datos. En MySQL esto se consigue con prefijos en los nombres de tablas. En PostgreSQL esto permite seguridad aplicada a grupos de tablas.
Tablespace: Área de almacenamiento en disco desde el punto de vista de las tablas. Los tablespaces están asignados a directorios, con lo que es posible tener diferentes tablas en diferentes directorios, en diferentes discos o incluso en diferentes sistemas de almacenamiento.
Rol: Una entidad que puede ser dueño de bases de datos, o tener permisos sobre bases de datos. Desde el punto de vista de PostgreSQL esto puede representar tanto un usuario, como un grupo, o ambas cosas. En MySQL roles y usuarios son conceptos separados: los roles son colecciones de permisos, y los usuarios entidades asociados a roles o bases de datos que permiten el acceso a los datos (en PostgreSQL ocurría lo mismo hasta la versión 9.0 en 2010). Los roles son únicos en cada cluster.
Tabla: una colección de datos relacionales. No hay diferencia con SQL o MySQL.
Vista: Una sentencia SQL que afecta a una o varias tablas, y se comporta como una tabla. No hay diferencia con SQL o MySQL.
Disparador (Trigger): Un disparador de eventos cuando se cambian los datos de una tabla. También existe en MYSQL, pero en PostgreSQL además existen los Event Triggers, que actúan cuando una tabla es creada, modificada o borrada.
# jerarquia de objetos 
![](img/jerarquia-objetos.png)

# CREAR BASES DE DATOS
Por defecto los cluster PostgreSQL proveen dos tablespaces: pg_default y pg_global. pg_global se usa para los catálogos compartidos de sistema (como en otros SGBD hay tablas que permiten consultar diversos datos sobre el sistema y sus contenidos, que luego veremos) y sus datos se guardan en global/ dentro del directorio del cluster. pg_default es el tablespace por defecto para toda las tabla de una base de datos (se pueden especificar otros tablespaces a nivel de base de datos, o tabla por tabla).

Dado que la gestión de tablespaces es importante, vamos a crear el primero, fuera del directorio del cluster.

¡Ten en cuenta que cuando hay tablespaces fuera del directorio del cluster, los backups y las restauraciones deben reflejar este hecho!

Esta es una operación sencilla.

Primero creamos una carpeta en la carpeta home del usuario postgres:

$ cd
 >>$ mkdir mitablespace
Y a continuación creamos creamos el tablespaces en PostgreSQL, asignándole la carpeta:

$ psql -c "CREATE TABLESPACE mitablespace LOCATION '/var/lib/pgsql/mitablespaces';"

Con el comando psql disponemos de varios comandos integrados para hacernos la vida más fácil.

Accede en modo interactivo:

$ psql

Y ejecuta '\?' para obtener ayuda

postgres-# \?
Por norma al añadir '+' al final de un comando, obtenemos una vista detallada, y en el caso de los tablespaces, eso ocurre con

postgres-# \db+

También podemos filtrar por el nombre de los objetos para algunos comandos, por ejemplo:

postgres-# \db+ mitablespace

o

postgres-# \db+ mitable*

Ahora que ya tenemos nuestro propio tablespace, crearemos dos bases de datos, una usando el tablespace por defecto, y otra el tablespace que hemos creado:

La sintaxis completa del comando para crear bases de datos es:

CREATE DATABASE name

[ [ WITH ] [ OWNER [=] user_name ]
       [ TEMPLATE [=] template ]
       [ ENCODING [=] encoding ]
       [ LC_COLLATE [=] lc_collate ]
       [ LC_CTYPE [=] lc_ctype ]
       [ TABLESPACE [=] tablespace_name ]
       [ ALLOW_CONNECTIONS [=] allowconn ]
       [ CONNECTION LIMIT [=] connlimit ]
       [ IS_TEMPLATE [=] istemplate ] ]
Lo más habitual es que usemos los parámetros OWNER (para especificar al rol dueño de la base de datos), LC_COLLATE (afecta al orden de las cadenas o string, de acuerdo al idioma especificado), LC_CTYPE (afecta a como se clasifican los caracteres, de acuerdo al idioma especificado) y TABLESPACE (especifica el table space por defecto para las tablas de la lista).

ALLOW_CONNECTIONS tiene valor 'true' por defecto, para permitir el acceso a usuarios, aunque a veces puede ser útil denegarlo (por ejemplo mientra preparamos más cosas en la base de datos).

CONNECTION_LIMIT permite especificar el número máximo de conexiones si lo deseamos.

TEMPLATE permite usar plantillas de bases de datos para la creación (que aportan valores por defecto, tablas por defecto, etc), o declarar una base de datos como plantilla. Consulta https://www.postgresql.org/docs/9.6/static/manage-ag-templatedbs.html para más información.

Comprueba las plantillas con el siguiente comando y presta atención a los valores:

postgres-# \l+ template*

Creemos ahora una base de datos con todos los parámetros por defecto:

postgres-# CREATE DATABASE midb0;

Introducción a psql
Los comandos comienzan siempre con el caracter \

Por ejemplo:

\? muestra la ayuda
Casi todos los comandos que emplearemos en el curso comienzan por \d (del inglés display, mostrar).

Por ejemplo:

\dt muestra las tablas
\dv muestra las vistas
\du muestra los roles
Además, añadiendo un + al comando se muestra más información sobre la tabla.

Por ejemplo:

\dt+ nos muestra también las políticas de seguridad de cada tabla
Por último, es posible filtrar los objetos que queremos añadiendo el nombre exacto a continuación del comando, siendo posible el uso del comodín *

Por ejemplo:

\dt mitabla* nos muestra todas las tablas cuyo nombre empiece por mitabla
Puedes obtener toda la información sobre la sentencia CREATE DATABASE en la documentación oficial

Plantillas PostgreSQL
Consulta la documentación oficial

¿UTF-8?
UTF-8 (8-bit Unicode Transformation Format) es un formato de codificación de caracteres Unicode, incluyendo estos la práctica totalidad de caracteres empleados en lenguas de actualizad, lenguas muertas, y muchos símbolos adicionales.

Lectura recomendada: ¿Qué es eso de ASCII ISO-8859-1 y UTF-8?

Ejercicio Práctico
¿Podrías ahora crear una base de datos cuyo dueño sea postgreSQL, que emplee el idioma español de España para LC_COLLATE y LC_TYPE, guarde sus tablas por defecto en el tablespace 'mitablespace'?

NOTA: cuando se quiere especificar una codificación, LC_COLLATE o LC_CTYPE distintos los establecidos para el cluster en postgresql.conf y que puedes ver en las plantillas template y template0, debes especificar siempre la plantilla template0.

postgres-# CREATE DATABASE midb1 WITH TEMPLATE = 'template0' LC_COLLATE = 'es_ES.UTF-8' LC_CTYPE= 'es_ES.UTF-8' TABLESPACE = 'mitablespace';

Como ves, mientra que el inglés de Estados Unidos se representa como en_US.UTF-8, en español de España se representa como es_ES.UTF-8.

Consulta ahora el listado de base de datos con:

postgres-# \l+ *

Para borrar, se usa el comando DROP DATABASE Consulta la documentación y prueba a borrar la base de datos midb0.

Solución:

postgres-# DROP DATABASE midb0;

Por otro lado, las tablas pueden tener esquemas (CREATE SCHEMA), tablas (CREATE TABLE) e índices (CREATE INDEX), o disparadores (CREATE TRIGGER), además de muchos otros elementos, siendo posible ajustar la configuración de seguridad para todos ellos, como veremos más adelante.

# CREAR USUARIOS Y ROLES

Lo más importante es recordar que, en PostgreSQL, los roles pueden representar usuarios, grupos, o incluso ambas cosas al mismo tiempo.

La familia de comandos que permiten gestionar roles son CREATE ROLE, DROP ROLE y ALTER ROLE.

La sintaxis completa de CREATE ROLE (la de ALTER ROLE es similar) es:

CREATE ROLE name [ [ WITH ] option [ ... ] ]

Opciones:

| SUPERUSER | NOSUPERUSER
| CREATEDB | NOCREATEDB
| CREATEROLE | NOCREATEROLE
| INHERIT | NOINHERIT
| LOGIN | NOLOGIN
| REPLICATION | NOREPLICATION
| BYPASSRLS | NOBYPASSRLS
| CONNECTION LIMIT connlimit
| [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'
| VALID UNTIL 'timestamp'
| IN ROLE role_name [, ...]
| IN GROUP role_name [, ...]
| ROLE role_name [, ...]
| ADMIN role_name [, ...]
| USER role_name [, ...]
| SYSID uid
SUPERUSER|NOSUPERUSER crea un rol como usuario superusuario o normal
CREATEDB|NOCREATEDB permite al rol crear (o no) bases de datos
CREATEROLE|NOCREATEROLE permite al rol crear (o no) nuevos roles (este caso y el anterior incluso si el rol no es super usuario)
INHERIT|NOINHERIT permite o deshabilita la herencia de privilegios de roles de los que el rol es miembro
LOGIN|NOLOGIN permite o deshabilita la identificación (NOLOGIN se usa normalmente para crear roles que se comportan como grupos)
REPLICATION|NOREPLICATION crea un rol con permisos o sin permisos de replicación (importante para conectar desde otros clusters y replicar, o para usar comandos que usen replicación como pg_basebackup)
BYPASSRLS|NOBYPASSRLS permita que el rol pueda ignorar (o no) políticas de seguridad para filas (row security policies), un tipo de seguridad SQL aplicada a filas que luego veremos brevemente. Es necesario para usa comandos como pg_dump.
CONNECTION LIMIT establece el número de conexiones máximas para el ROLE
[ENCRYPTED|UNENCRYPTED] PASSWORD ‘password’ establece una contraseña cifrado o no (normalmente solo es útil para roles que se comporten como usuario). Se recomienda usar el parámetro PASSWORD sin especificar encriptación o no, para que se active la encriptación (activa por defecto en postgresql.conf con el parámetro password_encryption). También es posible ajustar la contraseña a NULL para desactivar la identificación con contraseña
VALID UNTIL ‘timestamp’ permite ajustar una fecha de expiración
IN ROLE role_name [, …] permite declarar una lista de roles (separados por comas) a los que el usuario pertenece.
IN GROUP role_name [, …] es un alias IN ROLE, para retrocompatibilidad.
ROLE role_name [, …] permite añadir otros role a este.
ADMIN role_name [, …] permite añadir otros role a este, que pueden a su vez añadir nuevos roles
USER role_name [, …] es un alias a IN ROLE, para retrocompatibilidad
SYSID uid permite establecer un identificador único personalizado para el rol (todos los roles tienen un UID numérico que, normalmente, es autoasignado, al igual que ocurre con los usuarios de sistemas Unix).
Probemos ahora a crear un rol que se comporte como usuario no administrador:

postgres-# CREATE ROLE miusuario0 WITH LOGIN PASSWORD 'miclave0';

Lista ahora los roles:

postgres=# \du+

Prueba ahora a añadir dos roles:

El primero se llamará ‘miusuario1’, tendrá permitido identificarse con la clave ‘miclave1’ y no será superusuario, aunque si tendrá permitido crear roles.
El segundo se llamará ‘migrupo0’ y será de tipo no superusuario, no tendrá permitidas conexiones ni clave, pero permitirá crear bases de datos y además permitirá al rol ‘miusuario1’ añadir nuevos roles a ‘migrupo1’
Pausa el video e inténtalo durante nos minutos.

Solución:

postgres-# CREATE ROLE miusuario1 WITH LOGIN CREATEROLE PASSWORD 'miclave1';
postgres-# CREATE ROLE migrupo0 WITH NOLOGIN CREATEDB PASSWORD NULL ADMIN miusuario1;

Ahora ve a PgAdminIII y ciérralo.

Vuelve a abrirlo. Presiona con el botón derecho sobre la conexión ‘Curso PostgreSQL’ y selecciona ‘Properties…’, ajusta el usuaario a ‘miusuario1’ introduce la clave (‘miclave1’). Guarda y conecta.

Prueba a crear una rol nuevo (botón derecho sobre ‘Login roles’ y ‘New login role…’ con cualquier configuración, pero hazlo miembro de ‘migrupo0’ ¿Puedes?

Ahora prueba a crear una base de datos. Para ello ejecutaremos una consulta SQL. Y para poder hacerlo debemos ir a ‘Databases’ y pinchar sobre una de las bases de datos. Eso nos activará el botón ‘SQL’ del menú.

Pinchamos el botón ‘SQL’ y escribimos CREATE DATABASE mydb2; y presionamos el botón verde de play. ¿Funciona? Para el video y consulta https://www.postgresql.org/docs/9.6/static/sql-createrole.html para encontrar la respuesta.

La respuesta es que los privilegios CREATEDB o CREATEROLE no se heredan automáticamente. Es preciso hacer explicíto el rol que los permite, con el comando SET ROLE.

Vuelve a la consulta SQL de PgAdminIII, y añade ‘SET ROLE migrupo0;’ en una nueva línea antes de ‘CREATE DATABASE mydb2;’. Y ejecuta la consulta ¿funciona?

Desgraciadamente CREATE DATABASE tiene que ir en su propia consulta. Ejecuta primero SET ROLE migrupo0;, luego borra la consulta y ejecuta CREATE DATABASE mydb2; y verás que sí funciona.

Finalmente, como casi todos los objetos en PostgreSQL, se puede emplear el comando ALTER para efectuar modificaciones.

¿Podrías quitarle al rol ‘miusuario1’ quitarle el permiso para crear roles? Pausa el video unos instantes y consulta la documentación de ALTER ROLE.

Solución:

Para eliminar el permiso CREATEROLE:

En nuestra consola, con acceso con el usuario postgres:

postgres-# ALTER ROLE miusuario1 WITH NOCREATEROLE;

Como has visto en la documentación, NO es posible modificar la pertenencia de un rol a otro rol usando ALTER rol. Para añadir o eliminar roles de un rol, necesitamos usar los comandos GRANT y REVOKE que veremos a continuación.

No apagues la máquina (puedes suspenderla si lo deseas), ya que la usaremos tras la siguiente sección.